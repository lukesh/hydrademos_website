<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <sectionGroup name="weborb">
      <section name="logging" type="Weborb.Config.LoggingConfigHandler, weborb" />
      <section name="compression" type="Weborb.Config.CompressionConfigHandler, weborb" />      
      <section name="instrumentation" type="Weborb.Config.InstrumentationConfigHandler, weborb" />      
      <section name="performance" type="Weborb.Config.PerformanceConfigHandler, weborb" />      
      <section name="activators" type="Weborb.Config.ActivatorsConfigHandler, weborb" />      
      <section name="inspectors" type="Weborb.Config.InspectorsConfigHandler, weborb" />
      <section name="invokers" type="Weborb.Config.InvokersConfigHandler, weborb" />
      <section name="services" type="Weborb.Config.ServicesConfigHandler, weborb" />
      <section name="abstractClassMappings" type="Weborb.Config.AbstractMappingsConfigHandler, weborb" />      
      <section name="customWriters" type="Weborb.Config.CustomWritersConfigHandler, weborb" />            
      <section name="messageServer" type="Weborb.Messaging.Config.MessageServerConfig, weborb" />
      <section name="security" type="Weborb.Security.SecurityConfigHandler, weborb" />
      <section name="acl" type="Weborb.Security.AclConfigHandler, weborb" />
      <section name="serviceFactories" type="Weborb.Config.ServiceFactoriesConfigHandler, weborb" />
      <section name="argumentFactories" type="Weborb.Config.ArgumentFactoriesConfigHandler, weborb" />
      <section name="alternateConfigPath" type="Weborb.Config.AlternateConfigPathHandler, weborb" />
      <section name="datasets" type="Weborb.Config.DatasetConfigPathHandler, weborb" />
      <section name="protocols" type="Weborb.Config.ProtocolsConfigHandler, weborb" /> 
      <section name="classMappings" type="Weborb.Config.ClassMappingsHandler, weborb" /> 
      <section name="serialization" type="Weborb.Config.SerializationConfigHandler, weborb" />       
    </sectionGroup>
  </configSections>
  
  <weborb version="3.5" hotDeploy="no">
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========             C O M P R E S S I O N                  ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   WebORB can automatically compress AMF responses when they are larger than the specified 
   size. WebORB checks if the client accepts a particular compression algorithm. The 
   product supports two compression algortihms: gzip and deflate. The product will use the
   algorithm specified in the "algorithm" element.
  ==================================================================================== -->  
  <compression enable="yes">
    <!-- Threshold is the number of bytes in a response when the compression should
         be turned on. Zero (0) is a special value which enables compression for all 
         responses. -->
    <threshold>20480</threshold>
    <algorithm>gzip</algorithm>
  </compression>
  
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========             L O G G I N G                         ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   WebORB logging policies and categories. Logging policies control how log events
   are displayed or persisted. Logging categories control which events are enabled
   To disable a category, change the 'enabled' attribute value to "no"
  ==================================================================================== -->  
  <logging>
  
    <!-- enter the name of the logging policy. the name must match the value from the
    <policyName> element from one of the logging policies listed below -->
    <currentPolicy>Date Based Logging</currentPolicy>

    <!-- File Size Threshold policy - All log events are saved in a file. As soon as the
    file reaches the size specified in the <value> element of the fileSize parameter, the
    policy rolls logging over to a new file -->
    <loggingPolicy>
      <policyName>File Size Threshold</policyName>
      <className>Weborb.Util.Logging.Policies.SizeThresholdPolicy</className>
      <!-- the fileSize parameter specifies the size of the file in KB before a new file is created -->
      <parameter>
        <name>fileSize</name>
        <value>1024</value>
      </parameter>
      <!-- the fileName parameter specifies the prefix of the log file name.
      WebORB adds sequential numbers at the end of the prefix  -->
      <parameter>
        <name>fileName</name>
        <value>webORB_log</value>
      </parameter>
    </loggingPolicy>


    <!-- Date based logging - All log events are saved in a file corresponding to the
    date when the events occured. When the product is restarted, the same log file is used
    to store the log events. If the date changes while the product is running, log events
    issued on the new date are saved in a new file -->
    <loggingPolicy>
      <policyName>Date Based Logging</policyName>
      <className>Weborb.Util.Logging.Policies.DatePolicy</className>
    </loggingPolicy>

    <loggingPolicy>
      <policyName>Console</policyName>
      <className>Weborb.Util.Logging.Policies.ConsoleLoggingPolicy</className>
    </loggingPolicy>
    
    <loggingPolicy>
      <policyName>Specific File</policyName>
      <className>Weborb.Util.Logging.Policies.SpecificFilePolicy</className>
      <parameter>
        <name>fileName</name>
        <value>webORB1_log.txt</value>
      </parameter>
    </loggingPolicy>
  
    <log enable="yes">WEBORB INFO</log>
    <log enable="no">WEBORB DEBUG</log>
    <log enable="yes">WEBORB ERROR</log>
    <log enable="no">WEBORB SERIALIZATION</log>
    <log enable="yes">WEBORB EXCEPTION</log>
    <log enable="yes">WEBORB INSTRUMENTATION</log>
    <log enable="yes">WEBORB SECURITY</log>
    <log enable="yes">WEBORB MESSAGE SERVER</log>
    <log enable="no">WEBORB THREADING</log>        
  </logging>  
  
  
  <!-- =============================================================================== -->
  <!-- =====                                                              ============ -->
  <!-- =====     I N V O C A T I O N    I N S T R U M E N T A T I O N     ============ -->
  <!-- =====                                                              ============ -->
  <!-- ===============================================================================
  Object invocations handled by WebORB can be automatically instrumented. WebORB records
  instrumentation data in the Windows Performance Counters. When the feature is enabled,
  the product creates the "WebORB" performance counter category. For each invoked method
  the following counters are available:
    Invocation count
    Last invocation time
    Average invocation time
    Fastest invocation time
    Slowest invocation time
 ==================================================================================== -->
  <instrumentation enable="no" />
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========             P E R F O R M A N C E                 ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  This section of the config file configures various parts of the product which may impact 
  the overall performance of WebORB. For more details read notes for each element
  ==================================================================================== -->  
  <performance>
    <!-- the responseBuffer element control the Buffer propery on the System.Web.HttpResponse
         object used by WebORB to serialize AMF responses. For more details see:
         http://msdn2.microsoft.com/en-us/library/ms526001.aspx -->
    <responseBuffer enable="yes" />
  </performance>  
  
  
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========               P R O T O C O L S                   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  WebORB is a multi-protocol presentation server. The same server instance can process
  requests in different formats. Protocol parsers can be plugged in using the protocolHandler
  element below. Protocol handlers must implement the weborb.protocols.IMessageFactory
  interface. Interface implementations must have default no-arg constructor.
  ==================================================================================== -->
  <protocols>
        <!-- WOLF protocol handler -->
        <protocolHandler>Weborb.Protocols.Wolf.RequestParser</protocolHandler>

        <!-- AMF/ Flash Remoting protocol handler -->
        <protocolHandler>Weborb.Protocols.Amf.RequestParser</protocolHandler>
  </protocols>


  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========      C L I E N T   C L A S S   M A P P I N G      ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  To simplify the translation between client and server-side data classes, WebORB provides a
  class mapping facility. Using the format below you can specify names of the data classes
  used on the client side and map them to the corresponding classes on the server side. These
  mappings take effect under the following conditions:
  1. When a client sends an object of a particular class as an argument to a method call
     and the server-side method's formal argument is an interface, an abstract class or 
     a generic base class. In these cases, the server-side class must be either an 
     implementation of the interface or a assignable from the specified abstract or base class.
     These mappings take the precedence over the "abstractClassMappings" configuration.
  2. When a server as a result of a method invocation returns an object of a class that has
     a mapping below, WebORB will format response such that the client-side system 
     understands which client-side class should be used  
  ==================================================================================== -->
  <classMappings>
        <classMapping>
            <clientClass>ArgumentMetadata</clientClass>
            <serverClass>Weborb.Inspection.ArgumentDescriptor</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>FunctionMetadata</clientClass>
            <serverClass>Weborb.Inspection.MethodDescriptor</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>ServiceMetadata</clientClass>
            <serverClass>Weborb.Inspection.ServiceDescriptor</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>RecordSet</clientClass>
            <serverClass>Weborb.Reader.Dataset.DataSetInfo</serverClass>
        </classMapping>
        <classMapping>
          <clientClass>NetConfigDebug</clientClass>
          <serverClass>System.Object</serverClass>
        </classMapping>        
        <classMapping>
            <clientClass>flex.messaging.messages.AsyncMessage</clientClass>
            <serverClass>Weborb.V3Types.AsyncMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.messaging.messages.CommandMessage</clientClass>
            <serverClass>Weborb.V3Types.ReqMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.messaging.messages.RemotingMessage</clientClass>
            <serverClass>Weborb.V3Types.ReqMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.messaging.messages.AcknowledgeMessage</clientClass>
            <serverClass>Weborb.V3Types.AckMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.messages.DataMessage</clientClass>
            <serverClass>Weborb.V3Types.DataMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.messages.PagedMessage</clientClass>
            <serverClass>Weborb.V3Types.PagedMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.messages.SequencedMessage</clientClass>
            <serverClass>Weborb.V3Types.SeqMessage</serverClass>
        </classMapping>        
        <classMapping>
            <clientClass>flex.messaging.messages.ErrorMessage</clientClass>
            <serverClass>Weborb.V3Types.ErrMessage</serverClass>
        </classMapping>
        <classMapping>
          <clientClass>flex.messaging.messages.DataErrorMessage</clientClass>
          <serverClass>Weborb.V3Types.ErrDataMessage</serverClass>
        </classMapping>    
        <classMapping>
            <clientClass>flex.data.messages.UpdateCollectionMessage</clientClass>
            <serverClass>Weborb.V3Types.UpdateCollMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.UpdateCollectionRange</clientClass>
            <serverClass>Weborb.V3Types.UpdateCollRange</serverClass>
        </classMapping>         
        <classMapping>
          <clientClass>flex.messaging.io.ObjectProxy</clientClass>
          <serverClass>Weborb.Util.ObjectProxy</serverClass>
        </classMapping>
        <classMapping>
          <clientClass>flex.messaging.io.ArrayCollection</clientClass>
          <serverClass>Weborb.Util.ObjectProxy</serverClass>
        </classMapping>
  </classMappings>

  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========   A L T E R N A T E   C O N F I G   P A T H       ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   When WebORB configuration is updated via Management Console, the product
   automatically attempts to save the changes. If for some reason the file cannot be 
   saved, an alternative location can be specified with the <alternateConfigPath>
   property. In most cases the reason why the original config file cannot be saved
   is because of missing security permissions.
  ==================================================================================== -->  
  <alternateConfigPath>c:\\weborb\\</alternateConfigPath>


  
    
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========           N A M E D    S E R V I C E S            ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Named services is a feature unique to WebORB. It allows to hide the name of the concrete
  class (type) or a web service from the flash client side. A class (type) name is mapped to a
  logical name which is used in the NetConnection.getService call.
  To create a named service definition, create a <service> element. The <name> subelement
  contains the assigned logical name. The <serviceId> element contains the name of the class,
  web service WSDL URL, EJB JNDI location, etc.
  ==================================================================================== -->
  <services>
    <!-- named services defined for console security panel -->
    <service>
        <name>flashorbHttpHandler</name>
        <serviceId>Weborb.ORBHttpHandler</serviceId>
    </service>

    <service>
        <name>flashorbInspector</name>
        <serviceId>Weborb.Dispatch.Inspector</serviceId>
    </service>

    <service>
        <name>flashorbInvoker</name>
        <serviceId>Weborb.Dispatch.Invoker</serviceId>
    </service>

    <service>
        <name>flashorbObjectHandler</name>
        <serviceId>Weborb.Handler.ObjectHandler</serviceId>
    </service>

    <service>
        <name>flashorbWebServiceHandler</name>
        <serviceId>Weborb.Handler.WebServiceHandler</serviceId>
    </service>
        
    <service>
        <name>serverInfo</name>
        <serviceId>Weborb.Console.Info.ServerInfo</serviceId>
    </service>
    
    <service>
        <name>Administration</name>
        <serviceId>Weborb.Config.Administration</serviceId>
    </service>

    <service>
        <name>CallTraceBrowser</name>
        <serviceId>Weborb.Console.CallMonitor.CallTraceBrowser</serviceId>
    </service>

    <service>
        <name>ORBSecurity</name>
        <serviceId>Weborb.Security.ORBSecurity</serviceId>
    </service>

    <service>
        <name>SingleIPRestriction</name>
        <serviceId>Weborb.Security.SingleIPRestriction</serviceId>
    </service>

    <service>
        <name>IPRangeRestriction</name>
        <serviceId>Weborb.Security.IPRangeRestriction</serviceId>
    </service>

    <service>
        <name>HostNameRestriction</name>
        <serviceId>Weborb.Security.HostNameRestriction</serviceId>
    </service>

    <service>
        <name>RoleNameRestriction</name>
        <serviceId>Weborb.Security.RoleNameRestriction</serviceId>
    </service>
    
        <service>
        <name>autoupdater</name>
        <serviceId>Weborb.Service.AutoUpdater</serviceId>
    </service>    
    
    <!-- MESSAGING SERVICES AND OBJECTS -->
    
    <service>
        <name>streamFilenameGenerator</name>
        <serviceId>Weborb.Messaging.Server.Stream.DefaultStreamFilenameGenerator</serviceId>
    </service>    

    <service>
        <name>consumerService</name>
        <serviceId>Weborb.Messaging.Server.Stream.ConsumerService</serviceId>
    </service>  
            
    <service>
        <name>streamableFileFactory</name>
        <serviceId>Weborb.Messaging.Server.IO.StreamableFileFactory</serviceId>
    </service>              

    <service>
        <name>schedulingService</name>
        <serviceId>Weborb.Messaging.Server.Scheduling.Scheduler</serviceId>
    </service>              

    <service>
        <name>streamService</name>
        <serviceId>Weborb.Messaging.Server.Stream.StreamService</serviceId>
    </service>              

    <service>
        <name>providerService</name>
        <serviceId>Weborb.Messaging.Server.Stream.ProviderService</serviceId>
    </service>              

    <service>
        <name>flowControlService</name>
        <serviceId>Weborb.Messaging.Server.Stream.DummyFlowControlService</serviceId>
    </service>              

    <service>
        <name>videoCodecFactory</name>
        <serviceId>Weborb.Messaging.Server.Stream.VideoCodecFactory</serviceId>
    </service>              
    
    <service>
        <name>sharedObjectService</name>
        <serviceId>Weborb.Messaging.Server.SO.SharedObjectService</serviceId>
    </service>      
    
    <service>
        <name>playlistSubscriberStream</name>
        <serviceId>Weborb.Messaging.Server.Stream.PlaylistSubscriberStream</serviceId>
    </service>  
    
    <service>
        <name>clientBroadcastStream</name>
        <serviceId>Weborb.Messaging.Server.Stream.ClientBroadcastStream</serviceId>
    </service>      
    
<!--
    <service>
        <name>streamSecurityService</name>
        <serviceId></serviceId>
    </service>              
-->            
    
    <!-- Examples  -->
    <service>
        <name>ExamplesActivationSession</name>
        <serviceId>Weborb.Examples.ShoppingCart</serviceId>
    </service>

    <service>
        <name>computerinfo</name>
        <serviceId>Weborb.Examples.ComputerInfoService</serviceId>
    </service>

  </services>
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       S E R V I C E    A C T I V A T O R S        ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Service activator is responsible for creating or retrieving an instance of .NET object
  accordingly to a policy. Before a service invocation takes place, an object needs to be
  constructed or retrieved. For example, Session activator retrieves a service object from 
  the HTTP session associated with the client.
  To register an activator, create <activator> element. The <activationModeName> element
  must contain the name of the activation mode the activator will be responding to. The
  <className> element must contain the name of the activator class. The class must implement
  the Weborb.Activation.IActivator interface and must have default no-argument constructor.
  ==================================================================================== -->
  <activators>
    <activator>
      <activationModeName>request</activationModeName>
      <className>Weborb.Activation.RequestActivator</className>
    </activator>

    <activator>
      <activationModeName>session</activationModeName>
      <className>Weborb.Activation.SessionActivator</className>
    </activator>

    <activator>
      <activationModeName>application</activationModeName>
      <className>Weborb.Activation.ApplicationActivator</className>
    </activator>
  </activators>
  
  
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       S E R V I C E    I N S P E C T O R S        ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   Enter inspector full type name in the <serviceInspector> element.
   Create a separate element for each new service inspector. WebORB uses
   reflection to create instances of custom inspectors. Inspector class must
   have a default no-arg constructor and must implement the
   Weborb.Handler.IInspectionHandler interface
   ==================================================================================== -->
  <inspectors>
    <serviceInspector>Weborb.Handler.ObjectHandler</serviceInspector>
    <serviceInspector>Weborb.Handler.WebServiceHandler</serviceInspector>
    <!-- <serviceInspector>Weborb.Handler.CFCHandler</serviceInspector> -->
  </inspectors>  
 
 
 
 
 

  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       S E R V I C E    I N V O K E R S            ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Enter invoker full type name in the <serviceInvoker> element.
  Create new element for each invoker class. WebORB uses reflection to
  create instances of custom invokers. Invoker class must have default no-arg
  constructor and must implement the Weborb.Handler.IInvocationHandler
  interface
  ==================================================================================== -->
  <invokers>
    <serviceInvoker>Weborb.Handler.ObjectHandler</serviceInvoker>
    <serviceInvoker>Weborb.Handler.WebServiceHandler</serviceInvoker>   
    <!-- <serviceInvoker>Weborb.Handler.CFCHandler</serviceInvoker> -->
  </invokers>
 
 
 
 
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========      S E R V I C E   F A C T O R I E S            ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   Service object factories are responsible for creating new instances of
   objects on which the invocations will take place. By default WebORB
   uses default no-arg constructor to create new instances. Using service
   object factory overrides that mechanism.
   ==================================================================================== -->
  <serviceFactories>
    <!--
     Each service object factory must be declared using the <serviceFactory>
     element. Each element must contain full type name for the actual service 
     object factory class and fully qualified classname for the class (interface) 
     the factory is responsible for creating.
    -->
    <serviceFactory>
      <!-- full type name of the service object. The class must implement 
      Weborb.Util.IServiceObjectFactory -->
      <serviceFactoryClassName></serviceFactoryClassName>
      <!-- fully qualified class name the service object
      factory is responsible for constructing -->
      <className></className>
    </serviceFactory>
    
    <serviceFactory>
      <serviceFactoryClassName>Weborb.Security.ORBSecurityFactory</serviceFactoryClassName>
      <className>Weborb.Security.ORBSecurity</className>
    </serviceFactory>    
  </serviceFactories>
 
 
 
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========      A R G U M E N T   F A C T O R I E S          ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   Argument object factories are responsible for creating new instances of
   method arguments which will be passed into method invocations. By default WebORB
   uses argument adaptation logic where Flash ActionScript data types are converted
   into the argument types of the invoked method. Using argument object factories
   overrides the default adaptation logic mechanism.
   ==================================================================================== -->
  <argumentFactories>
    <!--
     Eeach argument object factory must be declared using the <argumentFactory>
     element. Each element must contain type name for the actual argument object 
     factory class and name for the class (interface) the factory is responsible 
     for creating.
    -->
    <argumentFactory>
      <!-- class name of the service object. The class must implement 
      Weborb.Util.IArgumentObjectFactory -->
      <argumentFactoryClassName>Weborb.Management.Security.SecurityRestrictionArgFactory</argumentFactoryClassName>
      <!-- Name of the class the service object factory is responsible for constructing -->
      <className>Weborb.Security.IRestriction</className>
    </argumentFactory>
    
    <argumentFactory>
      <argumentFactoryClassName>Weborb.V3Types.BodyHolderFactory</argumentFactoryClassName>
      <className>Weborb.V3Types.BodyHolder</className>
    </argumentFactory>    

    <argumentFactory>
      <argumentFactoryClassName>Weborb.Service.ArrayUpdateDataObjectFactory</argumentFactoryClassName>
      <className>Weborb.Service.ArrayUpdateData</className>
    </argumentFactory>

    <argumentFactory>
      <argumentFactoryClassName>Weborb.Management.Configuration.Logging.LoggingPolicyArgFactory</argumentFactoryClassName>
      <className>Weborb.Util.Logging.ILoggingPolicy</className>
    </argumentFactory>    
    
    <argumentFactory>
      <argumentFactoryClassName>Weborb.Examples.ArgumentFactory</argumentFactoryClassName>
      <className>System.Collections.Generic.List`1[[Weborb.Examples.Car, weborb, Version=3.1.0.1, Culture=neutral, PublicKeyToken=null]]</className>
    </argumentFactory>    
  </argumentFactories>      
  


<!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       A B S T R A C T    M A P P I N G S          ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  If an abstract class or an interface is used an argument type in a method invocation,
  a concrete class must be used to represent the interface or the abstract class.  
  The abstract class mapping feature is designed to map non-abstract class to an interface 
  or abstract class it implements or extends.
  To create an abstract type mapping, use the <abstractClassMapping> element. The <className>
  subelement must define the name of an abstract class or an interface. The <mappedClassName>
  element must contain the name of the concrete class providing an implementation of the
  specified interface or the abstract class.
  ==================================================================================== -->
  <abstractClassMappings>
    <abstractClassMapping>
        <className>System.Collections.ICollection</className>
        <mappedClassName>System.Collections.ArrayList</mappedClassName>
    </abstractClassMapping>

    <abstractClassMapping>
        <className>System.Collections.IList</className>
        <mappedClassName>System.Collections.ArrayList</mappedClassName>
    </abstractClassMapping>

    <abstractClassMapping>
        <className>System.Collections.IDictionary</className>
        <mappedClassName>System.Collections.Hashtable</mappedClassName>
    </abstractClassMapping>

    <abstractClassMapping>
        <className>System.Collections.Generic.IDictionary`2</className>
        <mappedClassName>System.Collections.Generic.Dictionary`2</mappedClassName>
    </abstractClassMapping>

    <abstractClassMapping>
        <className>System.Collections.Generic.IList`1</className>
        <mappedClassName>System.Collections.Generic.List`1</mappedClassName>
    </abstractClassMapping>
  </abstractClassMappings>

  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========   C U S T O M   T Y P E   S E R I A L I Z E R S   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Type serializers are responsible for writing .NET objects to the AMF format. WebORB
  provides support for most common types as well as an ability to override or extend the
  default behavior.
  Use <customWriter> element to register new custom serializers. Each writer must be declared
  as a mapping between the type it is responsible for serializing objects of class defined in \
  <className> and the class name of the actual writer class <writerClassName>. 
  Custom writer class must implement the Weborb.Writer.ITypeWriter interface and must 
  have default no-argument constructor
  ==================================================================================== -->
  <customWriters>
    <!--
    <customWriter>
        <className></className>
        <writerClassName></writerClassName>
    </customWriter>
    -->  
    <customWriter>
        <className>Weborb.Messaging.Channel.SubscriberInfo</className>
        <writerClassName>Weborb.Messaging.Channel.SubscriberInfoWriter</writerClassName>
    </customWriter>

    <customWriter>
        <className>Weborb.Messaging.Channel.SubscribersEvent</className>
        <writerClassName>Weborb.Messaging.Channel.SubscribersEventWriter</writerClassName>
    </customWriter> 
    
    <customWriter>
        <className>Weborb.V3Types.BodyHolder</className>
        <writerClassName>Weborb.V3Types.BodyHolderWriter</writerClassName>
    </customWriter> 
    
    <customWriter>
        <className>Weborb.Messaging.Net.RTMP.Status.StatusObject</className>
        <writerClassName>Weborb.Messaging.Net.RTMP.Status.StatusObjectWriter</writerClassName>
    </customWriter>
    
  </customWriters>
  
  
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========     S E R I A L I Z A T I O N    P R O P S        ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  This section contains various serialization related configuration settings. It is mostly
  a placeholder for future config items  
  ==================================================================================== -->
  <serialization>
    <serializePrivateFields>no</serializePrivateFields>
    <!-- if set to 'yes', instances of ICollection serialized as ArrayCollection 
         objects for Flex clients -->
    <legacyCollectionSerialization>no</legacyCollectionSerialization>
    <!-- serializer class responsible for enum type serialization. Consider the following
         enum class and service:
         
         public enum MyColor
         {
            Red = 100,
            Green = 200,
            Blue = 300            
         }
         
         public class MyService
         {
            public MyColor getColor()
            {
               return MyColor.Red;
            }
         }
         
         WebORB provides three options:
         
         1. Weborb.Writer.EnumerationWriter - serializes enum values as strings. 
            For the example above, it will serialize the value as "Red"
            
         2. Weborb.Writer.EnumAsNumberWriter - serializes enum values as numbers. 
            Will serialize the value in the example above as 100;
            
         3. Weborb.Writer.EnumAsObjectWriter - provides a combination of (1) and (2) and serializes
            enum types as a complex type containing both name and code. 
            Will serialize the return value in the example above as a complex type with
            properties "name" and "code":
                name - Red                
                code - 100
                
         To implement a custom enum type writer, create a public class and inherit from 
         Weborb.Writer.EnumerationWriter -->
                
    <enumerationSerializer>Weborb.Writer.EnumerationWriter</enumerationSerializer>
  </serialization>




 <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========                 D A T A S E T S                   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  The datasets node controls various serialization aspects of System.Data.DataSet.
  These settings apply only to Flash and AJAX clients. Dataset serialization to 
  Flex clients follow different rules. Flex clients receive data sets as AS objects where
  keys are mapped to the table names and values are arrays of objects. Each object 
  represents a row in the corresponding table.
  AJAX and Flash clients receive dataset as a RecordSet object. 
  ==================================================================================== -->
  <datasets>
    <!--  Controls how many records from data tables are returned with the first request.  -->
      <defaultPageSize>10</defaultPageSize>
    <!-- Version 3.2 changes how DataSet objects are serialized to Flash and AJAX clients.
         The default serialization logic writes DataSets as AS objects with keys are mapped
         to the table names and values are array of row objects. Use the <legacySerialization>
         node to change the serialization format to the pre-3.2 algorithm. If legacy 
         serialization is one (use value 'yes'), DataSets are serialized as arrays of arrays
         IF there is more than one table in a dataset. Otherwise if a dataset has just one 
         table, it is serialized as an array of row objects. -->
    <legacySerialization>no</legacySerialization>
  </datasets>



    
 <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========                 S E C U R I T Y                   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Security configuration consists of declaration of protected resources and
  access constraints. The resources are described by the <secure-resource>
  elements, access constraints are defined with the <access-constraint>
  element. Access constraints are not coupled to the resources, these are
  generic definitions of access limitations. One can define multiple constraints
  for the group of users/computers. A resource lists all the applicable
  constraints via the <constrain-name> elements.
  ==================================================================================== -->
  <security>
  <!--
    the <deploymentMode> element controls how the classes and assemblies in the WebORB-enabled
    application are exposed to the flash remoting clients.
    The 'open system' deployment mode exposes ALL classes in the application to Flash clients. 
    Security restrictions for the individual methods, classes and namespaces can still apply.
    The 'closed system' deployment model denies access to ALL classes except for the ones explicitly
    exposed with the <secure-resource> elements. 
    -->
    <deploymentMode>open</deploymentMode>

    <!--
    Authentication handler is responsible for authenticating user credentials passed along
    with an invocation. If specified, the handler is invoked every time when the credentials
    are passed along with an invocation. Handler invocation takes place before any WebORB 
    does and invocation processing. If the credentials cannot be authenticated, 
    FlashORBAuthenticationException must be thrown to indicate the failure. Error message 
    and error code from passed into the exception constructor are delivered to the client.
    Class specified in the authenticationHandler must implement the Weborb.Security.IAuthenticationHandler
    interface.
    -->
    <authenticationHandler>Weborb.Security.WebORBAuthenticationHandler</authenticationHandler>

    <!--
    Authorization handler is responsible for making a decision whether a request to access a resource
    should be allowed. The default implementation of the authorization handler checks if any of the 
    access constraints associated with the resource grant or deny access to the resource. 
    An authorization handler must implement the Weborb.Security.IAuthorizationHandler interface and 
    must have a default no-argument constructor. To override the global authorization handler, 
    individual services may have their own service-level authorization handler. If one is specified, 
    it takes priority over the the global handler when the resource is accessed.
    -->
    <authorizationHandler>Weborb.Security.WebORBAuthorizationHandler</authorizationHandler>
    
    
    <!--
    The roles provider is a class implementing the Weborb.Security.IRolesProvider interface. An
    implementation must return a list of security roles the application can be secured with.
    Administrator can use the roles in the management console to restrict access to the code.
    -->
    <rolesProvider>Weborb.Security.WebORBRolesProvider</rolesProvider>
    
    
    <secure-resources>
      <secure-resource>
        <!--
        method - name of the method in the format of serviceid.methodname
        service - id of the service to secure (fully qualified class name, WSDL URL)
        assembly name - name of the assembly to secure with the specified containt(s)
        namespace - name of the namespace, in the form of My.Assembly.*        
        named service - name of the resource as it is defined in the named services section
        -->
        <resource>ORBSecurity</resource>

        <!--
        Specify the name of a constraint to secure the resource.
        Multiple constraint-name elements are allowed
        -->
        <constraint-name>localhost constraint</constraint-name>
      </secure-resource>

      <secure-resource>
         <resource>Weborb.Management.*</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>


      <secure-resource>
         <resource>Weborb.Examples.AccountBalance</resource>
         <constraint-name>noone</constraint-name>
      </secure-resource>

      <secure-resource>
         <resource>Weborb.Examples.InvocationTests.SecureTest</resource>
         <constraint-name>noone</constraint-name>
      </secure-resource>

      
<!--
      <secure-resource>
         <resource>Weborb.Management.*</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>

      <secure-resource>
         <resource>WeborbManagement</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>

      <secure-resource>
         <resource>WeborbConfiguration</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
-->
      
      <!-- 
      ****************************************************
      Security declaration for the system level resources.
      These declarations must be present in the config file
      when WebORB runs in the 'closed system' mode.
      The default access level is 'everyone', thus exposing
      WebORB itself (but not the deployed application) to
      all potential clients. 
      *****************************************************
      -->
      <secure-resource>
         <resource>flashorbHttpHandler</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbInspector</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbInvoker</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbObjectHandler</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbWebServiceHandler</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>                  
      <secure-resource>
         <resource>Weborb.Dispatch.V3Dispatcher</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>                        
      
      <!-- end of system level resources -->

      <secure-resource>
         <resource>serverInfo</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>Administration</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>CallTraceBrowser</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>      
      <secure-resource>
         <resource>SingleIPRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>IPRangeRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>HostNameRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>RoleNameRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>System.*</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>Microsoft.*</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
    </secure-resources>

    <access-constraints>
      <!--
      Define access constaints with the <access-constraint> elements.
      The action attribute is required. valid values are "grant" and "reject".
      A single access-constraint element may have a combination of the following
      constraints:
            - zero or more IP address
            - zero or more IP range
            - zero or more hostnames
            - zero or more user roles
            - zero or more java package name patterns
      A constraint element must have a name, so it can be reused for securing
      multiple resources
      -->
      <access-constraint action="grant">

        <!--
        Name of the access constraint
        -->
        <name>localhost constraint</name>
        <!--
        This can be either a single ip address (212.45.21.112)
        or a mask of ip addresses (212.45.*.*)
        Multiple IP elements allowed

        <IP></IP>
        -->

        <!--
        Range of ip addresses. Use either specific addresses or masks.
        Multiple IPrange elements allowed

        <IPrange>
          <subnet-address></subnet-address>
          <subnet-mask></subnet-mask>
        </IPrange>
        -->

        <!--
        this can be either a single hostname (themidnightcoders.com),
        or a pattern of host names (*.themidnightcoders.com)
        Multiple hostname elements allowed
        -->
        <hostname>localhost</hostname>

        <!--
        Define role-based access constrains using the role element. The roles must be
        defined using in acl.xml file. Multiple <role> elements allowed

        <role></role>
        -->
      </access-constraint>
      <access-constraint action="grant">
        <name>everyone</name>
        <IP>*.*.*.*</IP>
      </access-constraint>
      
      <access-constraint action="grant">
        <name>everyone</name>
        <IP>*.*.*.*</IP>
      </access-constraint>

     <access-constraint action="reject">
       <name>noone</name>
       <IP>*.*.*.*</IP>
     </access-constraint>

    </access-constraints>
  </security>
  
  <acl>
    <user>
        <name>admin</name>
        <password>changeme</password>
        <role>administrator</role>
    </user>
    <user>
        <name>testuser</name>
        <password>password</password>
        <role>examplesuser</role>
    </user>
  </acl>
      
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========          M E S S A G E   S E R V E R              ================= -->
  <!-- ===========                                                   ================= -->
  <!-- =============================================================================== -->
  
  <messageServer>

    <handlerChains>
      <!--
      <handlerChain>        
        <factoryClass></factoryClass>        
        <preExecutionChain>
          <handlerClass></handlerClass>
          <handlerClass></handlerClass>
        </preExecutionChain>
        <postExecutionChain>
          <handlerClass></handlerClass>
          <handlerClass></handlerClass>
        </postExecutionChain>
      </handlerChain>
      -->

      <handlerChain>
        <!-- factory must be an instance of Weborb.Messageserver.IMessageFactory -->
        <factoryClass>Weborb.Messaging.Message.DefaultXMLMessageFactory</factoryClass>
        <!-- handlers must be instances of Weborb.Messageserver.IMessageHandler -->
        <postExecutionChain>
          <handlerClass>Weborb.Messaging.Message.Handler.MessageDeliveryHandler</handlerClass>
        </postExecutionChain>
      </handlerChain>

      <handlerChain>
        <factoryClass>Weborb.Messaging.Message.DefaultMessageFactory</factoryClass>
        <postExecutionChain>
          <handlerClass>Weborb.Messaging.Message.Handler.MessageDeliveryHandler</handlerClass>
        </postExecutionChain>
      </handlerChain>
    </handlerChains>

    <messageFactories>
      <serverDomain>
        <serverName>default</serverName>
        <port>9000</port>
        <defaultXMLMessageFactory>Weborb.Messaging.Message.DefaultXMLMessageFactory</defaultXMLMessageFactory>
        <messageFactory>
          <messageRootElement>join</messageRootElement>
          <factoryClassName>Weborb.Messaging.Message.System.JoinCommandMessageFactory</factoryClassName>
        </messageFactory>
        <messageFactory>
          <messageRootElement>deliverTo</messageRootElement>
          <factoryClassName>Weborb.Messaging.Message.System.DeliverCommandMessageFactory</factoryClassName>
        </messageFactory>
        <messageFactory>
          <messageRootElement>getSubscribers</messageRootElement>
          <factoryClassName>Weborb.Messaging.Message.System.GetSubscribersMessageFactory</factoryClassName>
        </messageFactory>
        <messageFactory>
          <messageRootElement>changeLogicalName</messageRootElement>
          <factoryClassName>Weborb.Messaging.Message.System.ChangeLogicalNameCommandMessageFactory</factoryClassName>
        </messageFactory>
      </serverDomain>
    </messageFactories>
  </messageServer>   
    
  </weborb>
</configuration>